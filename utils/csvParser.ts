
import Papa from 'papaparse';
import { Player, Lineup, ContestState } from '../types';
import { deriveContest } from './contest';

/**
 * Sanitizes non-standard JSON tokens like NaN or Infinity before parsing.
 * Essential for pipeline artifacts generated by Python/Pandas.
 */
export const safeJsonParse = (content: any): any => {
  if (typeof content !== 'string') return content;
  try {
    const sanitized = content
      .replace(/\bNaN\b/g, 'null')
      .replace(/\b-?Infinity\b/g, 'null');
    return JSON.parse(sanitized);
  } catch (e) {
    console.error("Safe JSON Parse failed:", e);
    throw e;
  }
};

export const normalizeName = (name: string): string => {
  return name.toLowerCase()
    .replace(/\s+(jr|sr|ii|iii|iv|v|1st|2nd|3rd)(\.?)$/g, '')
    .replace(/[^a-z]/g, '')
    .trim();
};

const normalizeKey = (key: string) => key.toLowerCase().replace(/[^a-z0-9]/g, '');

export const canonicalizeId = (id: any): string => {
  if (id === null || id === undefined) return '';
  const s = String(id).replace(/,/g, '').trim();
  if (!s || s === '0') return '';
  const n = Number(s);
  if (!isNaN(n) && Number.isFinite(n)) {
    return String(Math.trunc(n));
  }
  return s;
};

const toPct = (val: any): number => {
  if (val === undefined || val === null) return 0;
  const s = String(val).replace(/%/g, '').trim();
  const n = parseFloat(s);
  if (isNaN(n)) return 0;
  if (n > 0 && n < 1.0) return n * 100;
  return n;
};

export const buildPlayerIndex = (pool: Player[]) => {
  const byId = new Map<string, Player>();
  const byName = new Map<string, Player>();

  pool.forEach(p => {
    const rawId = String(p.id).trim();
    const canonical = canonicalizeId(rawId);
    byId.set(rawId, p);
    if (canonical && canonical !== rawId) byId.set(canonical, p);
    const norm = normalizeName(p.name);
    if (!byName.has(norm)) byName.set(norm, p);
  });

  return {
    find: (val: string): Player | undefined => {
      const cleanVal = val.trim();
      if (!cleanVal || cleanVal === '0') return undefined;
      const canonical = canonicalizeId(cleanVal);
      if (byId.has(cleanVal)) return byId.get(cleanVal);
      if (byId.has(canonical)) return byId.get(canonical);
      
      const parenMatch = cleanVal.match(/\(([^)]+)\)$/);
      if (parenMatch) {
        const extracted = parenMatch[1].trim();
        const extractedCanonical = canonicalizeId(extracted);
        if (byId.has(extracted)) return byId.get(extracted);
        if (byId.has(extractedCanonical)) return byId.get(extractedCanonical);
      }
      
      const normVal = normalizeName(cleanVal);
      return byName.get(normVal);
    }
  };
};

const HEADER_MAP = {
  name: ['playername', 'name', 'player'],
  id: ['id', 'playerid', 'dkid', 'fdid', 'dk_id', 'player_id'],
  position: ['pos', 'position', 'positions'],
  team: ['team', 'teamabbrev'],
  salary: ['salary', 'sal'],
  projection: ['fpts', 'proj', 'projection', 'points', 'dkfptsproj', 'dk_fpts_proj'],
  ceiling: ['ceil', 'ceiling', 'max'],
  floor: ['floor', 'min'],
  ownership: ['own', 'ownership', 'pown', 'ownmean', 'own_mean', 'ownership_pct'],
  lineupId: ['lineup', 'lineupid', 'entry', 'lineup#', 'lineup_id']
};

export const parseProjections = (file: File | string): Promise<Player[]> => {
  return new Promise((resolve, reject) => {
    const config = {
      header: true,
      skipEmptyLines: true,
      complete: (results: any) => {
        const players: Player[] = [];
        const headers = results.meta.fields || [];
        const map: Record<string, string> = {};
        
        headers.forEach((h: string) => {
          const norm = normalizeKey(h);
          for (const [key, candidates] of Object.entries(HEADER_MAP)) {
            if (candidates.some(c => norm.includes(c) || c === norm)) {
              if (!map[key]) map[key] = h;
            }
          }
        });

        results.data.forEach((row: any, index: number) => {
          const name = row[map.name || 'Name'] || row['Player Name'] || row['Player'];
          if (!name) return;

          // Non-lossy parsing: Start with ALL original columns
          const player: Player = {
            ...row,
            id: canonicalizeId(row[map.id || 'ID'] || row['ID'] || `${name}-${index}`),
            name,
            position: row[map.position || 'Position'] || 'FLEX',
            team: row[map.team || 'Team'] || row['TeamAbbrev'] || 'UNK',
            salary: parseFloat(row[map.salary || 'Salary'] || '0') || 0,
            projection: parseFloat(row[map.projection || 'Fpts'] || '0') || 0,
            ceiling: parseFloat(row[map.ceiling || 'Ceiling'] || '0') || 0,
            floor: parseFloat(row[map.floor || 'Floor'] || '0') || 0,
            ownership: parseFloat(row[map.ownership || 'Own%'] || '0') || 0,
            value: 0
          };

          // Also ensure any keys that look like numbers are stored as numbers for sorting/filtering
          Object.keys(player).forEach(key => {
            const val = player[key];
            if (typeof val === 'string' && val.trim() !== '') {
              const num = Number(val.replace(/,/g, ''));
              if (!isNaN(num) && isFinite(num) && !key.toLowerCase().includes('id')) {
                 player[key] = num;
              }
            }
          });

          players.push(player);
        });
        resolve(players);
      },
      error: (err: any) => reject(err),
    };
    Papa.parse(file, config);
  });
};

export const parseOptimizerLineupsFromRows = (rows: any[], playerPool: Player[], source: Lineup['lineupSource'] = 'optimizer_csv'): Lineup[] => {
  const lineups: Lineup[] = [];
  if (!rows || rows.length === 0) return lineups;

  const indexer = buildPlayerIndex(playerPool);
  const headers = Object.keys(rows[0]);

  const headerMap = {
    ev: headers.find(h => ['simev', 'ev', 'mean'].includes(h.toLowerCase())),
    roi: headers.find(h => ['simroi', 'roi'].includes(h.toLowerCase())),
    win: headers.find(h => ['win_prob%', 'winpct', 'win%'].includes(h.toLowerCase())),
    top10: headers.find(h => ['top10%', 'top10pct'].includes(h.toLowerCase())),
    cash: headers.find(h => ['cash%', 'cashpct'].includes(h.toLowerCase())),
    tail: headers.find(h => ['tail_ev', 'tailscore'].includes(h.toLowerCase())),
    rank: headers.find(h => ['final_rank_score', 'finalscore', 'score'].includes(h.toLowerCase())),
    set: headers.find(h => ['set', 'type'].includes(h.toLowerCase())),
    id: headers.find(h => ['lineup_id', 'lineupid', 'id', 'entry'].includes(h.toLowerCase()))
  };

  const dkSlots = ['PG', 'SG', 'SF', 'PF', 'C', 'G', 'F', 'UTIL'];
  const playerCols = dkSlots.map(slot => headers.find(h => h.toUpperCase() === slot)).filter(Boolean) as string[];
  const usePFormat = playerCols.length < 8;
  const activeCols = usePFormat 
    ? headers.filter(h => /^p\d+$/i.test(h)).sort((a, b) => parseInt(a.slice(1)) - parseInt(b.slice(1)))
    : playerCols;

  rows.forEach((row: any, index) => {
    const matchedPlayers: Player[] = [];
    const missingRefs: string[] = [];
    const playerIds: string[] = [];
    const rawPlayerRefs: string[] = [];

    activeCols.forEach(col => {
      const rawVal = String(row[col] || '').trim();
      if (rawVal && rawVal !== '0') {
        const cid = canonicalizeId(rawVal);
        rawPlayerRefs.push(rawVal);
        playerIds.push(cid);
        const p = indexer.find(rawVal);
        if (p) {
          matchedPlayers.push(p);
        } else {
          missingRefs.push(cid);
        }
      }
    });

    if (playerIds.length === 0) return;

    const lineupIdRaw = String(row[headerMap.id || ''] || index + 1);
    lineups.push({
      id: `${source === 'reference' ? 'Ref' : 'OPT'}-${lineupIdRaw}`,
      lineupIdRaw,
      playerIds,
      players: matchedPlayers,
      totalSalary: matchedPlayers.reduce((s, p) => s + p.salary, 0),
      totalProjection: matchedPlayers.reduce((s, p) => s + p.projection, 0),
      totalCeiling: matchedPlayers.reduce((s, p) => s + (p.ceiling || 0), 0),
      totalOwnership: matchedPlayers.reduce((s, p) => s + (p.ownership || 0), 0),
      set: (row[headerMap.set || ''] || 'Unknown') as any,
      simEV: headerMap.ev ? parseFloat(row[headerMap.ev]) : undefined,
      simROI: headerMap.roi ? toPct(row[headerMap.roi]) : undefined,
      winProbPct: headerMap.win ? toPct(row[headerMap.win]) : undefined,
      top10Pct: headerMap.top10 ? toPct(row[headerMap.top10]) : undefined,
      cashPct: headerMap.cash ? toPct(row[headerMap.cash]) : undefined,
      tailEV: headerMap.tail ? parseFloat(row[headerMap.tail]) : undefined,
      finalRankScore: headerMap.rank ? parseFloat(row[headerMap.rank]) : undefined,
      lineupSource: source,
      rawPlayerRefs,
      missingRefs,
      missingCount: missingRefs.length
    });
  });
  
  return lineups;
};

export const parseOptimizerLineupsFromText = (text: string, playerPool: Player[], source: Lineup['lineupSource'] = 'optimizer_csv'): Lineup[] => {
  const result = Papa.parse(text, { header: true, skipEmptyLines: true });
  return parseOptimizerLineupsFromRows(result.data, playerPool, source);
};

export const parseOptimizerLineups = (file: File, playerPool: Player[]): Promise<Lineup[]> => {
  return new Promise((resolve, reject) => {
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => resolve(parseOptimizerLineupsFromRows(results.data, playerPool)),
      error: (err) => reject(err)
    });
  });
};

export const parseUserLineupsRows = (file: File): Promise<Lineup[]> => {
  return new Promise((resolve, reject) => {
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => {
        const headers = results.meta.fields || [];
        const normHeaders = headers.map(normalizeKey);
        const map: Record<string, string> = {};
        for (const [key, candidates] of Object.entries(HEADER_MAP)) {
          const idx = normHeaders.findIndex(nh => candidates.includes(nh));
          if (idx !== -1) map[key] = headers[idx];
        }
        if (!map.lineupId) {
          reject(new Error("Add a Lineup_ID column so we can group players into lineups."));
          return;
        }
        const grouped = new Map<string, any[]>();
        results.data.forEach((row: any) => {
          const lid = String(row[map.lineupId] || '').trim();
          if (!lid) return;
          if (!grouped.has(lid)) grouped.set(lid, []);
          grouped.get(lid)?.push(row);
        });
        const lineups: Lineup[] = [];
        grouped.forEach((rows, lid) => {
          const matchedPlayers: Player[] = rows.map((row, idx) => ({
            id: canonicalizeId(row[map.id] || `USR-${lid}-${idx}`),
            name: row[map.name] || 'Unknown',
            position: row[map.position] || 'UTIL',
            team: row[map.team] || 'UNK',
            salary: parseFloat(row[map.salary] || '0') || 0,
            projection: parseFloat(row[map.projection] || '0') || 0,
            ownership: parseFloat(row[map.ownership] || '0') || 0,
            ceiling: parseFloat(row[map.ceiling] || '0') || 0,
            floor: parseFloat(row[map.floor || '0']) || 0
          }));
          lineups.push({
            id: `USR-${lid}`,
            lineupIdRaw: lid,
            playerIds: matchedPlayers.map(p => p.id),
            players: matchedPlayers,
            totalSalary: matchedPlayers.reduce((s, p) => s + p.salary, 0),
            totalProjection: matchedPlayers.reduce((s, p) => s + p.projection, 0),
            totalOwnership: matchedPlayers.reduce((s, p) => s + (p.ownership || 0), 0),
            totalCeiling: matchedPlayers.reduce((s, p) => s + (p.ceiling || 0), 0),
            lineupSource: 'player_row_csv',
            missingCount: matchedPlayers.length === 8 ? 0 : (8 - matchedPlayers.length)
          });
        });
        resolve(lineups);
      },
      error: (err) => reject(err)
    });
  });
};

export const parsePipelineJson = (content: any): { referencePlayers: Player[]; contestState?: ContestState; diagnostics?: any; meta?: any; referenceLineups?: Lineup[]; files?: any } => {
  const json = safeJsonParse(content);
  let referencePlayers: Player[] = [];
  let referenceLineups: Lineup[] = [];
  let contestState: ContestState | undefined = undefined;

  const playersData = json.data?.projections ?? json.players ?? json.projections;

  if (Array.isArray(playersData)) {
    referencePlayers = playersData.map((p: any, i: number) => {
      const team = (p.TeamAbbrev ?? p.Team ?? p.team ?? 'UNK').toUpperCase();
      const rawId = p.ID ?? p.Id ?? p.id ?? p.DK_ID ?? p.dk_id ?? p.playerId;
      
      let opponent = p.opponent ?? 'UNK';
      const gameInfo = p["Game Info"] || p["GameInfo"] || p.game_info;
      if (gameInfo && typeof gameInfo === 'string') {
        const matchup = gameInfo.split(' ')[0]; 
        if (matchup.includes('@')) {
          const parts = matchup.split('@');
          const teamA = parts[0].toUpperCase();
          const teamB = parts[1].toUpperCase();
          opponent = teamA === team ? teamB : teamA;
        }
      }

      const player: Player = {
        ...p, // Non-lossy spread from JSON data
        id: canonicalizeId(rawId || `${p.Name ?? p.name}-${i}`),
        name: p.Name ?? p.name,
        team,
        opponent,
        position: Array.isArray(p.Position) ? p.Position.join('/') : (p.Position ?? 'FLEX'),
        salary: Number(p.Salary ?? p.salary ?? 0),
        projection: Number(p.DK_FPTS_PROJ ?? p.projection ?? 0),
        ceiling: Number(p.CEILING ?? p.ceiling ?? 0),
        floor: Number(p.FLOOR ?? p.floor ?? 0),
        ownership: Number(p.OWN_MEAN ?? p.OWNERSHIP ?? p["Own%"] ?? 0),
        value: 0
      };
      
      return player;
    });

    const optLineups = json.data?.optimized_lineups ?? json.lineups;
    if (optLineups) {
      referenceLineups = parseOptimizerLineupsFromRows(Array.isArray(optLineups) ? optLineups : (optLineups.optimizer_core || []), referencePlayers, 'reference');
    }
  }

  if (json.contest) {
    const input = {
      contestName: json.contest.name || 'Reference Contest',
      site: (json.contest.site || 'DraftKings') as any,
      entryFee: Number(json.contest.entry_fee || 0),
      fieldSize: Number(json.contest.field_size || 0),
      maxEntries: Number(json.contest.max_entries || 20),
      rakePct: Number(json.contest.rake_pct || 0) > 1 ? Number(json.contest.rake_pct) / 100 : Number(json.contest.rake_pct || 0),
      paidPctGuess: 0.22, 
    };
    contestState = { input, derived: deriveContest(input) };
  }
  return { referencePlayers, contestState, diagnostics: json.diagnostics, meta: json.meta, referenceLineups, files: json.files };
};
